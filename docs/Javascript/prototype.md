# 프로토타입을 사용하는 이유

# wiki 정리

프로토타입 기반 프로그래밍?

- 객체지향 프로그래밍의 한 갈래
- 클래스 기반 언어에서 상속을 사용하는 것과 다르게, 객체를 `원형`(프로토타입)으로 하여 `복제`의 과정을 통해 객체의 동작방식을 다시 사용하는 것

## 클래스 기반 프로그래밍과의 비교

| 객체

1. `클래스` : 객체의 기본적인 메서드, 속성을 정의

- 구조를 정의

2. `인스턴스` : 사용할 수 있는 객체

| 객체 생성

1. 클래스

- 클래스의 생성자를 이용하여 인스턴스를 생성
- 결과로 만들어진 인스턴스는 클래스의 설계, 메서드를 따르게 되어있음

2. 프로토타입
   새 객체를 만드는 두 가지 방법

- 원래 있던 객체를 Clone하는 방법 -> 대부분
- 새로운 객체를 생성하는 방법

> 기본적인 프로토타입인 `Object`를 가짐

# MDN 정리 Object Prototypes

## 1. 프로토타입 기반 언어

| 모든 객체들이 메소드+속성을 상속받기 위한 탬블릿으로서 프로토타입 객체를 가진다는 의미

- 해당 프로토타입 객체는 다시 상위 프로토타입 객체를 상속받을 수 있다.
- 이를 프로토타입 체인이라고 한다

> 다른 객체에 정의되어 있는 메소드+속성을 사용할 수 있도록 한다.

## 2. `prototype`

| 상속되는 메서드+속성은 객체의 생성자의 `prototyp`이라는 속성에 정의되어 있다

## 3. 프로토타입 객체

| 프로토타입 객체에서 한 객체의 메소드+속성은 다른 객체로 복사되는 것이 아닙니다

- 프로토타입 체인을 타며 올라가서 접근할 뿐입니다

## 4. 프로토타입 객체에 접근

| 공식적으로 프로토타입 객체에 바로 접근하는 방법은 없습니다

- JS표준에서는 `[[prototype]]` 내부속성으로 정의되어 있습니다.
- 브라우저차원에서 `__proto_-`속성을 통해 특정 객체의 프로토타입객체에 접근할 수 있도록 구현되어있습니다
- ES2015부터는 Object.getPrototypeOf(obj) 함수를 통해 프로토타입 객체에 바로 접근 할 수 있습니다

# 프로토타입 (ProtoType) - 코어스크립트 정리

`키워드`

`Constructor`
`instance`
`__proto__`

생성자 함수를 new 연산자와 함께 호출하면
Constructor에 정의된 내용으로 새로운 인스턴스가 생성
새로운 인스턴스에는 `__proto__`라는 property가 자동으로 부여
`__proto__` property에는 Constructor의 prototype이라는 property을 참조

Ex1 )

Person 생성자의 prototype에 getName메서드를 지정

```js
var Person = function(name) {
  this._name = name;
};

Person.prototype.getName = function() {
  return this._name;
};
```

Person인스턴스는 `__proto__` 프로퍼티를 통해 호출할 수 있음

```js
var suzi = new Person("suzi");
suzi.__proto__.getName(); //undefined
```

1. undefined가 발생했다는 이유는, 에러가 발생하지 않았다는 점과 같습니다
2. 즉 변수가 호출할 수 있는 함수에 해당하는 것입니다
3. 결과로 getName이 함수라는 것

### this

어떤 함수를 '메서드로서' 호출할 때는 메서드명 바로 앞의 객체가 this가 됩니다

- 예를들어 `thomas.__proto__.getName()`에서 getName함수 내부에서의 this는 thomas가 아니라 thomas.**proto**라는 객체가 되는 것입니다
- 이 객체에는 name프로퍼티가 없으므로 찾고자 하는 식별자가 정의되지 않는 경우 에러가 아닌 undefined를 반환합니다

### 관건은 this

- this를 인스턴스로 할 수 있다면?

- `__proto__`를 빼면 this는 instance가 되고, 메서드가 호출되어 원하는 값이 나옵니다

### 왜?

- `__proto__` 가 생략 가능한 프러퍼티이기 때문, 원래부터 생략가능하기 구조되어있다!

- 그냥 그런가보다 하는 수밖에 없다!

### 그래서?

> new 연산자로 constructor를 호출하면 instance가 만들어지는데, 이 instance의 생략 가능한 프로퍼티인 **proto**는 Constructor의 prototype을 참조한다

> 생성자 함수의 prototype의 어떤 메서드나 프러퍼티가 있다면, 인스턴스에서도 마치 자신의 것처럼 해당 메서드나 프로퍼티에 접근할 수 있게 됩니다

# `[[Prototype]]`

| 객체는 `[[Prototype]]`이라는 은닉 속성을 가짐

- 자신의 프로토타입이 되는 객체를 가르킨다
- 프로토타입 체인을 타고 올라가다가, `null`을 프로토타입으로 가지는 프로토타입 체인의 종점역할을 하는 객체에서 끝나게 된다.

## 속성 상속

- 객체의 어떤 속성에 접근하려고 할 때, 그 객체 자체 속성뿐만 아니라 객체의 프로토타입, 그 프로토타입의 프로토타입등 프로토타입 체인의 종점에 이를 때 까지 속성을 탐색한다

# self check

1. `[[Prototype]]` 이란?
2. `__prototype__` 이란?
3. 프로토타입 체인 이란?
4. Constructor 프로퍼티란?
