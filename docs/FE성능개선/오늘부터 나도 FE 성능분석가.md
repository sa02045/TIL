# 성능 분석가의 관심사 (GOAL)

첫 번째, 서버 성능분석의 관심사는?
| 서버가 얼마나 빠른가, 얼마나 많은 요청을 처리하는가?
TPS가 중요(Transition Per Seconds)

두 번째, FE 성능분석의 관심사는?
| 사용자의 입력에 따라 얼마나 빠르게 반응하는가?
LAL이 중요(Loading and Interaction)

## LAL

1. 초기 로딩 속도
   - 얼마나 빨리 페이지를 볼 수 있는가
2. 인터렉션 속도
   - 스크롤이 버벅거리는가
   - 키보드 입력이 버벅거리는가
   - 애니메이션이 매끄럽게 동작하는가

# 성능분석의 대상

| 숲을 보자

- 서비스에서 가장 많이 사용하는 화면은?
- 서비스에서 사용자에게 가장 가치있는 화면은?

# 개선 프로세스

1. 측정
2. 분석
3. 최적화

측정 -> 분석 -> 최적화 -> 측정 -> 분석.... 의 반복

언제까지? -> 도달할 때 까지

네이버는

- 모바일 1.5초
- PC 2초를 초기 페이지 로딩속도로 목표

# 성능 개선 시작하기

## 첫 번째, 로딩 속도 측정, 분석하기

| 핵심은 Waterfall 차트를 개선하는 것

- 높이를 줄이고
- 폭을 줄이고
- 간격을 땡기고
- 최종 점검하기

# 높이 줄이기 (요청 수를 줄이기)

1. JS, CSS Merge (Webpack)
2. CSS Sprite (재활용)
3. Data URI
   - 캐싱되지 않아도 될 이미지를 HTML 요청에 포함시키기

## 효과적인 방법

| 초기 로딩 시 불필요한 자원을 삭제하거나 Lazy하게 요청하기

- 실수로 요청한 자원
- 초기 로딩시 필요 없는 JS
- 뷰 포트 바깥에 있는 이미지등(슬라이더,carousel등)

### 뭐니뭐니해도 이미지

| 가장 많은 사이즈를 잡아 먹음

- 해결책은 Lazy 하게 이미지를 불러오는 것

### 그외

- 브라우저는 호스트마다 동시에 연결할 수 있는 개수가 정해져 있음
- 요청 수가 많으면 사용할 수 있는 connection 수를 초과하여 다른 요청은 브라우저에서 대기하게 됨
- 결국 , 요청은 적으면 적을 수록 좋다

# 폭 줄이기

| 많은 정보를 담고 있는 reqeust

## 1. Initial Connection

1. HTTP 프로토콜 마다 Connection 활용 방법이 다르다
2. 이 부분을 개선시키고 싶다면 HTTP2가 정답. 즉, 커넥션에 대한 튜닝은 프로토콜을 바꾸는 방법 밖에 없음

## 2. Time to First Byte(TTFB)

TTFB가 오래 걸린다는 뜻은, 서버 비지니스 로직이 느리다는 의미(서버가 느리다!)

- Content Download 문제면

  1. 네트워크 속도가 늦다
  2. Content Size가 크다

- 해결책은
  1. JS, CSS를 Minify한다
     - 주석제거, 공백제거
     - 변수명 변경하기
  2. gzip 적용하기
  3. 이미지는 포맷에 따라 성능이 차이남(png,jpg 등등...)
  4. 이미지의 메타정보(찍은 날짜등등)을 제거해서 최적화를 하는것이 좋음

## Decode 비용

| 이미지 데이터를 RGB로 변환하는 과정

Request -> Decode -> Copy to GPU -> Display

# 3. 간격땡기기 : Request 계단 간격을 땡겨보자

## 브라우저 렌더링 과정

1. 서버로부터 HTML 문자열을 Stream으로 받아와서
2. `<head>` 태그에 포함된 자원을 `병렬`로 다운로드
3. `<head>` 태그에 포함된 자원을 모두 실행함(그전까지는 브라우저는 흰 화면)
4. `<body>` 태그로부터 화면을 그리기 시작한다
5. DOM 구성이 완료되면 `DOMContentLoaded` 이벤트가 발생함
6. 모든 자원의 로딩이 완료되면 load이벤트가 발생함

### 그런데 여기서 JS는 DOM, CSSOM을 건드리를 수 있는 구조

| Render과정을 다시 거쳐야함

## 정리

1. Head태그에는 CSS와 필수 JS만 넣어라
   - 모두 다운로드, 실행되기 전에는 브라우저는 아무것도 그리지 않는다.
   - body 태그 마지막에 JS를 넣어라
     - 중간중간에 JS를 넣지마라
     - 왜냐하면 렌더링 블락이 생기기 때문이다
     - HTML파서가 파싱을 하면서 JS를 만나면 실행하기 때문

### async, defer

- DOM제어와 관련이 있는 스크립트와 defer를 사용
- 의존성이 없는 스크립트는 async를 사용

### CSS파일에서 폰트, 이미지를 사용하는 경우

- CSS가 불러와진 다음에 CSS에서 사용하는 폰트 이미지가 로딩됨
- 해결책 -> `preload` : 미리 자원을 부를 수 있음
- 또는 HTTP2 Server push : HTML과 함께 JS,CSS,이미지가 로딩됨

### 체감속도 높이기

1. First Paint: Head 태그 종료 후 그려짐
2. First Meaningful Paint: Hero 엘리먼트가 보이는 시기

위 두가지를 높이게 노력하면 체감속도가 높아짐

서비스 차원에서는

- Hero 엘리먼트
- Lazy하게 처리해야하는 요소를 결정해야 함

또는
Request의 균형감을 찾아야함

- 각각의 Request를 균등한 크기로 맞추기

# 인터렉션

| 상황에 따라 최적화 방법이 다르다
하지만 하나의 원리로 귀결

> 브라우저 Main Thread는 건드리지 않기!

## 문제는 동적언어 JS

| 자바스크립트가 DOM을 건드리면 기본적을 Main Thread에 의해서 Rendering Pipeline이 동작하게됨

### Rendering Pipeline이해하기

JS로 DOM을 변경하면

1. Style Recalculate : DOM의 최종 스타일을 계산
2. Layout : DOM의 배치와 크기를 계산함
3. Paint : 화면에 그림
4. Composition: 레이어를 조합

해결책 -> 최대한 덜 그리고, 적게 그리도록 만들어야함

#### 해결책

1. Layout이 발생하는 속성 건드리지 않기
2. 도와줘 GPU
   - Main Thread(CPU)가 아닌 GPU의 도움을 받기

#### GPU의 도움을 받기위해서 레이어를 만들기

- 브라우저가 규칙에 따라 레이어를 구성함
- 명시적으로 레이어를 구성하기

#### GPU의 Side Effect

- 레이어를 구성하는 작업은 초기에는 CPU가 진행
- 레이어에 원래 비트맵 정보를 복사하기 위해 2배의 메모리가 필요함
  | 해결책 -> 꼭 필요한 부분만 레이어로 만든다

#### 60FPS 보장하기

- 렌더링 파이프가 계속해서 발생하는 경우 1Frame은 16ms내에 완료되어야함
- 애니메이션에서는 requestAnimationFrame API으로 16ms 주기를 완료

#### DOM을 건드리지 않는 JS코드 실행시간도 동일

- 서비스 Biz 로직이 대다수...
- 서비스 개발자가 가장 잘 고칠 수 있음
